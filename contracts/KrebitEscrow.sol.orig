/*
// SPDX-License-Identifier: MIT
@author Krebit Inc. https://krebit.co
Based on LocalCryptos Escrow
Pay in Ethereum for digital or real-world goods and services
*/

pragma solidity ^0.8.0;

contract ERC20 {
    function transfer(address _to, uint256 _value)
        public
        returns (bool success);

    function transferFrom(
        address _from,
        address _to,
        uint256 _value
    ) public returns (bool success);

    function approve(address _spender, uint256 _value)
        public
        returns (bool success);

    function balanceOf(address account) public view returns (uint256);
}

contract KrebitEscrow {
    // The address of the arbitrator (Krebit Govern DAO)
    address public arbitrator;
    address public owner;
    address public relayer;
    uint32 public requestCancellationMinimumTime;
    uint256 public feesAvailableForWithdraw;

    ERC20 public reputationToken;
    uint256 public minReputationToSell;
    uint256 public minReputationToBuy;

    uint8 constant ACTION_BUYER_CANNOT_CANCEL = 0x01; // Called when marking as paid or calling a dispute as the seller
    uint8 constant ACTION_SELLER_CANCEL = 0x02;
    uint8 constant ACTION_BUYER_CANCEL = 0x03;
    uint8 constant ACTION_BUYER_REQUEST_CANCEL = 0x04;
    uint8 constant ACTION_RELEASE = 0x05;
    uint8 constant ACTION_DISPUTE = 0x06;

    event Created(bytes32 _tradeHash);
    event BuyerCancelDisabled(bytes32 _tradeHash);
    event BuyerRequestedCancel(bytes32 _tradeHash);
    event CancelledByBuyer(bytes32 _tradeHash);
    event CancelledBySeller(bytes32 _tradeHash);
    event Released(bytes32 _tradeHash);
    event DisputeResolved(bytes32 _tradeHash);

    struct Escrow {
        // Set so we know the trade has already been created
        bool exists;
        // The timestamp in which the buyer can cancel the trade if the seller has not yet marked as paid. Set to 0 on marked paid or dispute
        // 1 = unlimited cancel time
        uint32 buyerCanCancelAfter;
        // The total cost of gas spent by relaying parties. This amount will be
        // refunded/paid to Krebit once the escrow is finished.
        uint128 totalGasFeesSpentByRelayer;
    }
    // Mapping of active trades. Key is a hash of the trade data
    mapping(bytes32 => Escrow) public escrows;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyArbitrator() {
        require(msg.sender == arbitrator);
        _;
    }

    function getRelayedSender(
        bytes16 _tradeID, // The unique ID of the trade, generated by Krebit
        uint8 _actionByte, // The desired action of the user, matching an ACTION_* constant
        uint128 _maximumGasPrice, // The maximum gas price the user is willing to pay
        uint8 _v, // Signature value
        bytes32 _r, // Signature value
        bytes32 _s // Signature value
    ) private view returns (address) {
        bytes32 _hash = keccak256(_tradeID, _actionByte, _maximumGasPrice);
        if (tx.gasprice > _maximumGasPrice) return;
        return ecrecover(_hash, _v, _r, _s);
    }

    function KrebitEscrow(
        address _govern,
        address _krebitToken,
        uint256 _minReputationToSell,
        uint256 _minReputationToBuy
    ) public {
        /**
         * Initialize the contract.
         */
        owner = _govern;
        arbitrator = _govern;
        relayer = _govern;
        requestCancellationMinimumTime = 2 hours;
        reputationToken = _krebitToken;
        minReputationToSell = _minReputationToSell;
        minReputationToBuy = _minReputationToBuy;
    }

    function getEscrowAndHash(
        /**
         * Hashes the values and returns the matching escrow object and trade hash.
         * Returns an empty escrow struct and 0 _tradeHash if not found
         */
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee
    ) private view returns (Escrow, bytes32) {
        bytes32 _tradeHash = keccak256(_tradeID, _buyer, _seller, _value, _fee);
        return (escrows[_tradeHash], _tradeHash);
    }

    function createEscrow(
        /**
         * Create a new escrow and add it to `escrows`.
         * _tradeHash is created by hashing _tradeID, _buyer, _seller, _value and _fee variables. These variables must be supplied on future contract calls.
         */
        bytes16 _tradeID, // The unique ID of the trade, generated by Krebit
        address _buyer, // The selling party of the trade
        address _seller, // The buying party of the trade
        uint256 _value, // The ether amount being held in escrow
        uint16 _fee, // The Krebit fee in 1/10000ths
        uint32 _paymentWindowInSeconds, // The time in seconds from contract creation that the seller has to mark as paid
        uint32 _expiry // Provided by Krebit. This transaction must be created before this time.
    ) external payable {
        bytes32 _tradeHash = keccak256(_tradeID, _buyer, _seller, _value, _fee);
        require(!escrows[_tradeHash].exists); // Require that trade does not already exist
        //Instead of signature from relayer, check reputationToken balance
        require(reputationToken.balanceOf(_seller) >= minReputationToSell);
        require(reputationToken.balanceOf(_buyer) >= minReputationToBuy);
        require(block.timestamp < _expiry);
        require(msg.value == _value && msg.value > 0); // Check sent eth against signed _value and make sure is not 0
        uint32 _buyerCanCancelAfter = _paymentWindowInSeconds == 0
            ? 1
            : uint32(block.timestamp) + _paymentWindowInSeconds;
        escrows[_tradeHash] = Escrow(true, _buyerCanCancelAfter, 0);
        Created(_tradeHash);
    }

    uint16 constant GAS_doRelease = 36100;

    function doRelease(
        /**
         * Called by the buyer to releases the funds for a successful trade.
         * Deletes the trade from the `escrows` mapping.
         */
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _additionalGas
    ) private returns (bool) {
        var (_escrow, _tradeHash) = getEscrowAndHash(
            _tradeID,
            _buyer,
            _seller,
            _value,
            _fee
        );
        if (!_escrow.exists) return false;
        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer +
            (
                msg.sender == relayer
                    ? (GAS_doRelease + _additionalGas) * uint128(tx.gasprice)
                    : 0
            );
        delete escrows[_tradeHash];
        Released(_tradeHash);
        transferMinusFees(_seller, _value, _gasFees, _fee);
        return true;
    }

    uint16 constant GAS_doDisableBuyerCancel = 12100;

    function doDisableBuyerCancel(
        /**
         * Stops the buyer from cancelling the trade.
         * Can only be called the seller.
         * Used to mark the trade as paid, or if the seller has a dispute.
         */
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _additionalGas
    ) private returns (bool) {
        var (_escrow, _tradeHash) = getEscrowAndHash(
            _tradeID,
            _buyer,
            _seller,
            _value,
            _fee
        );
        if (!_escrow.exists) return false;
        if (_escrow.buyerCanCancelAfter == 0) return false;
        escrows[_tradeHash].buyerCanCancelAfter = 0;
        BuyerCancelDisabled(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(
                _tradeHash,
                GAS_doDisableBuyerCancel + _additionalGas
            );
        }
        return true;
    }

    uint16 constant GAS_doSellerCancel = 36100;

    function doSellerCancel(
        /**
         * Cancels the trade and returns the ether to the buyer.
         * Can only be called the seller.
         */
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _additionalGas
    ) private returns (bool) {
        var (_escrow, _tradeHash) = getEscrowAndHash(
            _tradeID,
            _buyer,
            _seller,
            _value,
            _fee
        );
        if (!_escrow.exists) return false;
        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer +
            (
                msg.sender == relayer
                    ? (GAS_doSellerCancel + _additionalGas) *
                        uint128(tx.gasprice)
                    : 0
            );
        delete escrows[_tradeHash];
        CancelledBySeller(_tradeHash);
        transferMinusFees(_buyer, _value, _gasFees, 0);
        return true;
    }

    uint16 constant GAS_doBuyerCancel = 36100;

    function doBuyerCancel(
        /**
         * Cancels the trade and returns the ether to the buyer.
         * Can only be called the buyer.
         * Can only be called if the payment window was missed by the seller
         */
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _additionalGas
    ) private returns (bool) {
        var (_escrow, _tradeHash) = getEscrowAndHash(
            _tradeID,
            _buyer,
            _seller,
            _value,
            _fee
        );
        if (!_escrow.exists) return false;
        if (
            _escrow.buyerCanCancelAfter <= 1 ||
            _escrow.buyerCanCancelAfter > block.timestamp
        ) return false;
        uint128 _gasFees = _escrow.totalGasFeesSpentByRelayer +
            (
                msg.sender == relayer
                    ? (GAS_doBuyerCancel + _additionalGas) *
                        uint128(tx.gasprice)
                    : 0
            );
        delete escrows[_tradeHash];
        CancelledByBuyer(_tradeHash);
        transferMinusFees(_buyer, _value, _gasFees, 0);
        return true;
    }

    uint16 constant GAS_doBuyerRequestCancel = 12100;

    function doBuyerRequestCancel(
        /**
         * Called by the buyer if the seller is unresponsive
         * Can only be called on unlimited payment window trades (buyerCanCancelAfter == 1)
         * Sets the payment window to `requestCancellationMinimumTime` from now, in which it can be cancelled.
         */
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _additionalGas
    ) private returns (bool) {
        // Called on unlimited payment window trades wheret the seller is not responding
        var (_escrow, _tradeHash) = getEscrowAndHash(
            _tradeID,
            _buyer,
            _seller,
            _value,
            _fee
        );
        if (!_escrow.exists) return false;
        if (_escrow.buyerCanCancelAfter != 1) return false;
        escrows[_tradeHash].buyerCanCancelAfter =
            uint32(block.timestamp) +
            requestCancellationMinimumTime;
        BuyerRequestedCancel(_tradeHash);
        if (msg.sender == relayer) {
            increaseGasSpent(
                _tradeHash,
                GAS_doBuyerRequestCancel + _additionalGas
            );
        }
        return true;
    }

    uint16 constant GAS_doResolveDispute = 36100;

    function resolveDispute(
        /**
         * Called by the arbitrator to resolve a dispute
         * Requires the signed ACTION_DISPUTE actionByte from either the seller or the buyer
         */
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        uint8 _sellerPercent
    ) external onlyArbitrator {
        address _signature = ecrecover(
            keccak256(_tradeID, ACTION_DISPUTE),
            _v,
            _r,
            _s
        );
        require(_signature == _seller || _signature == _buyer);

        var (_escrow, _tradeHash) = getEscrowAndHash(
            _tradeID,
            _buyer,
            _seller,
            _value,
            _fee
        );
        require(_escrow.exists);
        require(_sellerPercent <= 100);

        uint256 _totalFees = _escrow.totalGasFeesSpentByRelayer +
            GAS_doResolveDispute;
        require(_value - _totalFees <= _value); // Prevent underflow
        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw

        delete escrows[_tradeHash];
        DisputeResolved(_tradeHash);
        _seller.transfer(((_value - _totalFees) * _sellerPercent) / 100);
        _buyer.transfer(((_value - _totalFees) * (100 - _sellerPercent)) / 100);
    }

    function release(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee
    ) external returns (bool) {
        require(msg.sender == _buyer);
        return doRelease(_tradeID, _buyer, _seller, _value, _fee, 0);
    }

    function disableBuyerCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee
    ) external returns (bool) {
        require(msg.sender == _seller);
        return doDisableBuyerCancel(_tradeID, _buyer, _seller, _value, _fee, 0);
    }

    function sellerCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee
    ) external returns (bool) {
        require(msg.sender == _seller);
        return doSellerCancel(_tradeID, _buyer, _seller, _value, _fee, 0);
    }

    function buyerCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee
    ) external returns (bool) {
        require(msg.sender == _buyer);
        return doBuyerCancel(_tradeID, _buyer, _seller, _value, _fee, 0);
    }

    function buyerRequestCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee
    ) external returns (bool) {
        require(msg.sender == _buyer);
        return doBuyerRequestCancel(_tradeID, _buyer, _seller, _value, _fee, 0);
    }

    function relayBuyerCannotCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _maximumGasPrice,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external returns (bool) {
        return
            relay(
                _tradeID,
                _buyer,
                _seller,
                _value,
                _fee,
                _maximumGasPrice,
                _v,
                _r,
                _s,
                ACTION_BUYER_CANNOT_CANCEL,
                0
            );
    }

    function relaySellerCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _maximumGasPrice,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external returns (bool) {
        return
            relay(
                _tradeID,
                _buyer,
                _seller,
                _value,
                _fee,
                _maximumGasPrice,
                _v,
                _r,
                _s,
                ACTION_SELLER_CANCEL,
                0
            );
    }

    function relayRelease(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _maximumGasPrice,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external returns (bool) {
        return
            relay(
                _tradeID,
                _buyer,
                _seller,
                _value,
                _fee,
                _maximumGasPrice,
                _v,
                _r,
                _s,
                ACTION_RELEASE,
                0
            );
    }

    function relayBuyerCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _maximumGasPrice,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external returns (bool) {
        return
            relay(
                _tradeID,
                _buyer,
                _seller,
                _value,
                _fee,
                _maximumGasPrice,
                _v,
                _r,
                _s,
                ACTION_BUYER_CANCEL,
                0
            );
    }

    function relayBuyerRequestCancel(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _maximumGasPrice,
        uint8 _v,
        bytes32 _r,
        bytes32 _s
    ) external returns (bool) {
        return
            relay(
                _tradeID,
                _buyer,
                _seller,
                _value,
                _fee,
                _maximumGasPrice,
                _v,
                _r,
                _s,
                ACTION_BUYER_REQUEST_CANCEL,
                0
            );
    }

    function relay(
        bytes16 _tradeID,
        address _buyer,
        address _seller,
        uint256 _value,
        uint16 _fee,
        uint128 _maximumGasPrice,
        uint8 _v,
        bytes32 _r,
        bytes32 _s,
        uint8 _actionByte,
        uint128 _additionalGas
    ) private returns (bool) {
        address _relayedSender = getRelayedSender(
            _tradeID,
            _actionByte,
            _maximumGasPrice,
            _v,
            _r,
            _s
        );
        if (_relayedSender == _seller) {
            if (_actionByte == ACTION_BUYER_CANNOT_CANCEL) {
                return
                    doDisableBuyerCancel(
                        _tradeID,
                        _buyer,
                        _seller,
                        _value,
                        _fee,
                        _additionalGas
                    );
            } else if (_actionByte == ACTION_SELLER_CANCEL) {
                return
                    doSellerCancel(
                        _tradeID,
                        _buyer,
                        _seller,
                        _value,
                        _fee,
                        _additionalGas
                    );
            }
        } else if (_relayedSender == _buyer) {
            if (_actionByte == ACTION_RELEASE) {
                return
                    doRelease(
                        _tradeID,
                        _buyer,
                        _seller,
                        _value,
                        _fee,
                        _additionalGas
                    );
            } else if (_actionByte == ACTION_BUYER_CANCEL) {
                return
                    doBuyerCancel(
                        _tradeID,
                        _buyer,
                        _seller,
                        _value,
                        _fee,
                        _additionalGas
                    );
            } else if (_actionByte == ACTION_BUYER_REQUEST_CANCEL) {
                return
                    doBuyerRequestCancel(
                        _tradeID,
                        _buyer,
                        _seller,
                        _value,
                        _fee,
                        _additionalGas
                    );
            }
        } else {
            return false;
        }
    }

    uint16 constant GAS_batchRelayBaseCost = 28500;

    function batchRelay(
        /**
         * Call multiple relay methods at once to save on gas.
         */
        bytes16[] _tradeID,
        address[] _buyer,
        address[] _seller,
        uint256[] _value,
        uint16[] _fee,
        uint128[] _maximumGasPrice,
        uint8[] _v,
        bytes32[] _r,
        bytes32[] _s,
        uint8[] _actionByte
    ) public returns (bool[]) {
        bool[] memory _results = new bool[](_tradeID.length);
        uint128 _additionalGas = uint128(
            msg.sender == relayer ? GAS_batchRelayBaseCost / _tradeID.length : 0
        );
        for (uint8 i = 0; i < _tradeID.length; i++) {
            _results[i] = relay(
                _tradeID[i],
                _buyer[i],
                _seller[i],
                _value[i],
                _fee[i],
                _maximumGasPrice[i],
                _v[i],
                _r[i],
                _s[i],
                _actionByte[i],
                _additionalGas
            );
        }
        return _results;
    }

    function increaseGasSpent(bytes32 _tradeHash, uint128 _gas) private {
        /** Increase `totalGasFeesSpentByRelayer` to be charged later on completion of the trade.
         */
        escrows[_tradeHash].totalGasFeesSpentByRelayer +=
            _gas *
            uint128(tx.gasprice);
    }

    function transferMinusFees(
        address _to,
        uint256 _value,
        uint128 _totalGasFeesSpentByRelayer,
        uint16 _fee
    ) private {
        uint256 _totalFees = ((_value * _fee) / 10000) +
            _totalGasFeesSpentByRelayer;
        if (_value - _totalFees > _value) return; // Prevent underflow
        feesAvailableForWithdraw += _totalFees; // Add the the pot for localethereum to withdraw
        _to.transfer(_value - _totalFees);
    }

    function withdrawFees(address _to, uint256 _amount) external onlyOwner {
        /**
         * Withdraw fees collected by the contract. Only the owner can call this.
         */
        require(_amount <= feesAvailableForWithdraw); // Also prevents underflow
        feesAvailableForWithdraw -= _amount;
        _to.transfer(_amount);
    }

    function setArbitrator(address _newArbitrator) external onlyOwner {
        /**
         * Set the arbitrator to a new address. Only the owner can call this.
         * @param address _newArbitrator
         */
        arbitrator = _newArbitrator;
    }

    function setOwner(address _newOwner) external onlyOwner {
        /**
         * Change the owner to a new address. Only the owner can call this.
         * @param address _newOwner
         */
        owner = _newOwner;
    }

    function setRelayer(address _newRelayer) external onlyOwner {
        /**
         * Change the relayer to a new address. Only the owner can call this.
         * @param address _newRelayer
         */
        relayer = _newRelayer;
    }

    function setRequestCancellationMinimumTime(
        uint32 _newRequestCancellationMinimumTime
    ) external onlyOwner {
        /**
         * Change the requestCancellationMinimumTime. Only the owner can call this.
         * @param uint32 _newRequestCancellationMinimumTime
         */
        requestCancellationMinimumTime = _newRequestCancellationMinimumTime;
    }

    function setReputationToken(address _newToken) external onlyOwner {
        reputationToken = _newToken;
    }

    function setMinBalanceToSell(uint32 _newMinBalance) external onlyOwner {
        minReputationToSell = _newMinBalance;
    }

    function setMinBalanceToBuy(uint32 _newMinBalance) external onlyOwner {
        minReputationToBuy = _newMinBalance;
    }

    function transferToken(
        ERC20 _tokenContract,
        address _transferTo,
        uint256 _value
    ) external onlyOwner {
        /**
         * If ERC20 tokens are sent to this contract, they will be trapped forever.
         * This function is way for us to withdraw them so we can get them back to their rightful owner
         */
        _tokenContract.transfer(_transferTo, _value);
    }

    function transferTokenFrom(
        ERC20 _tokenContract,
        address _transferTo,
        address _transferFrom,
        uint256 _value
    ) external onlyOwner {
        /**
         * If ERC20 tokens are sent to this contract, they will be trapped forever.
         * This function is way for us to withdraw them so we can get them back to their rightful owner
         */
        _tokenContract.transferFrom(_transferTo, _transferFrom, _value);
    }

    function approveToken(
        ERC20 _tokenContract,
        address _spender,
        uint256 _value
    ) external onlyOwner {
        /**
         * If ERC20 tokens are sent to this contract, they will be trapped forever.
         * This function is way for us to withdraw them so we can get them back to their rightful owner
         */
        _tokenContract.approve(_spender, _value);
    }
}
